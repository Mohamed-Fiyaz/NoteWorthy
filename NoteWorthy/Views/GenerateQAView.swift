//
//  GenerateQAView.swift
//  NoteWorthy
//
//  Created by Mohamed Fiyaz on 16/03/25.
//

import SwiftUI
import PDFKit

struct GenerateQAView: View {
    let note: Note
    @StateObject private var viewModel = IrisViewModel()
    @State private var qaItems: [[String: String]] = []
    @State private var isGenerating = true
    @State private var showExportOptions = false
    @State private var exportURL: URL?
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("Q&A from Note")
                    .font(.headline)
                Spacer()
                if !qaItems.isEmpty {
                    Button(action: {
                        showExportOptions = true
                    }) {
                        Image(systemName: "square.and.arrow.up")
                            .foregroundColor(Color(#colorLiteral(red: 0.553298533, green: 0.7063716054, blue: 0.8822532296, alpha: 1)))
                    }
                }
            }
            .padding()
            .background(Color(.systemBackground))
            .overlay(
                Rectangle()
                    .frame(height: 0.5)
                    .foregroundColor(Color(.systemGray4)),
                alignment: .bottom
            )
            
            // Content
            if isGenerating {
                VStack {
                    Spacer()
                    LoadingAnimationView()
                    Text("Generating questions and answers...")
                        .foregroundColor(.gray)
                        .padding(.top)
                    Spacer()
                }
            } else if qaItems.isEmpty {
                VStack {
                    Spacer()
                    Image(systemName: "exclamationmark.circle")
                        .font(.system(size: 50))
                        .foregroundColor(.gray)
                    Text("Failed to generate Q&A")
                        .font(.headline)
                        .padding(.top)
                    Button("Try Again") {
                        isGenerating = true
                        generateQA()
                    }
                    .padding(.top)
                    Spacer()
                }
            } else {
                List {
                    ForEach(0..<qaItems.count, id: \.self) { index in
                        QAItemView(qa: qaItems[index], index: index)
                    }
                }
            }
        }
        .onAppear {
            generateQA()
        }
        .sheet(isPresented: $showExportOptions) {
            if let url = exportURL {
                ShareSheet(items: [url])
            }
        }
    }
    
    private func generateQA() {
        Task {
            if let result = await viewModel.generateQA(for: note.content),
               let questions = result["questions"] as? [[String: String]] {
                qaItems = questions
            }
            
            isGenerating = false
        }

    }
    
    private func generatePDF() -> URL? {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd_HHmmss"
        let timestamp = formatter.string(from: Date())
        let filename = "QA_\(note.title.replacingOccurrences(of: " ", with: "_"))_\(timestamp).pdf"
        
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(filename)
        
        let title = "Q&A Based on: \(note.title)"
        
        guard let pdfDocument = createQAPDF(title: title, qaItems: qaItems) else { return nil }
        
        pdfDocument.write(to: tempURL)
        return tempURL
    }
    
    private func createQAPDF(title: String, qaItems: [[String: String]]) -> PDFDocument? {
        let pdfMetadata = [
            kCGPDFContextCreator: "NoteWorthy App",
            kCGPDFContextAuthor: "Generated by Iris"
        ]
        
        let format = UIGraphicsPDFRendererFormat()
        format.documentInfo = pdfMetadata as [String: Any]
        
        let pageRect = CGRect(x: 0, y: 0, width: 8.5 * 72.0, height: 11 * 72.0)
        let renderer = UIGraphicsPDFRenderer(bounds: pageRect, format: format)
        
        let data = renderer.pdfData { context in
            context.beginPage()
            
            let titleFont = UIFont.boldSystemFont(ofSize: 24.0)
            let headerFont = UIFont.boldSystemFont(ofSize: 16.0)
            let bodyFont = UIFont.systemFont(ofSize: 14.0)
            
            // Draw title
            let titleAttributes: [NSAttributedString.Key: Any] = [
                .font: titleFont,
                .foregroundColor: UIColor.black
            ]
            
            let titleString = NSAttributedString(string: title, attributes: titleAttributes)
            let titleRect = CGRect(x: 72, y: 72, width: pageRect.width - 144, height: 50)
            titleString.draw(in: titleRect)
            
            // Draw Q&A items
            var yPosition = titleRect.maxY + 40
            
            for (index, qa) in qaItems.enumerated() {
                let questionAttributes: [NSAttributedString.Key: Any] = [
                    .font: headerFont,
                    .foregroundColor: UIColor.black
                ]
                
                let answerAttributes: [NSAttributedString.Key: Any] = [
                    .font: bodyFont,
                    .foregroundColor: UIColor.darkGray
                ]
                
                // Draw question
                let questionText = "Q\(index + 1): \(qa["question"] ?? "")"
                let questionString = NSAttributedString(string: questionText, attributes: questionAttributes)
                let questionRect = CGRect(x: 72, y: yPosition, width: pageRect.width - 144, height: 50)
                questionString.draw(in: questionRect)
                
                // Draw answer
                yPosition = questionRect.maxY + 10
                let answerText = "A: \(qa["answer"] ?? "")"
                let answerString = NSAttributedString(string: answerText, attributes: answerAttributes)
                let answerRect = CGRect(x: 72, y: yPosition, width: pageRect.width - 144, height: 200)
                answerString.draw(in: answerRect)
                
                // Calculate the size of the drawn text
                let answerBounds = answerText.boundingRect(
                    with: CGSize(width: pageRect.width - 144, height: .greatestFiniteMagnitude),
                    options: [.usesLineFragmentOrigin, .usesFontLeading],
                    attributes: answerAttributes,
                    context: nil
                )
                
                yPosition = yPosition + answerBounds.height + 30
                
                // Check if we need a new page
                if yPosition > pageRect.height - 72 && index < qaItems.count - 1 {
                    context.beginPage()
                    yPosition = 72
                }
            }
        }
        
        let pdfDocument = PDFDocument(data: data)
        return pdfDocument
    }
}

struct QAItemView: View {
    let qa: [String: String]
    let index: Int
    @State private var isExpanded = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                Text(qa["answer"] ?? "")
                    .font(.body)
                    .padding(.vertical, 8)
            },
            label: {
                Text("Q\(index + 1): \(qa["question"] ?? "")")
                    .font(.headline)
            }
        )
        .padding(.vertical, 4)
    }
}

struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]
    
    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: items, applicationActivities: nil)
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
